version: "3.4"

services:
  #
  # Main services
  #
  production:
    # command: "bundle exec puma"
    command: "/var/www/bin/script/entry.sh"
    tty: true
    stdin_open: true
    container_name: "ensl_production"
    user: "web:web"
    build:
      context: ./
      dockerfile: Dockerfile
      target: ensl_production
    volumes:
     - ".:/var/www/"
    environment:
      RAILS_ENV: production
    ports:
     - "${PUMA_PORT}:${PUMA_PORT}"
     # Guard livereload
     # - "35729:35729"
    links:
     - db
     - memcached
     - smtp

  staging:
    command: "/var/www/bin/script/entry.sh"
    # command: "bundle exec puma"
    # command: "/bin/bash"
    tty: true
    stdin_open: true
    container_name: "ensl_staging"
    user: "web:web"
    build:
      context: ./
      dockerfile: Dockerfile
      target: ensl_staging
    volumes:
     - ".:/var/www/"
    environment:
      RAILS_ENV: staging
    ports:
     - "9000:${PUMA_PORT}"
    links:
     - db
     - memcached
     - smtp

  development:
    # For debug; Use attach rather than this
    # command: /bin/bash
    command: "bundle exec puma"
    tty: true
    stdin_open: true
    container_name: "ensl_development"
    user: "web:web"
    build:
      context: ./
      dockerfile: Dockerfile
      target: ensl_${RAILS_ENV}
    volumes:
     - ".:/var/www/"
    environment:
      RAILS_ENV: $RAILS_ENV
    ports:
     - "${PUMA_PORT}:${PUMA_PORT}"
     - "35729:35729"
    links:
     - db
     - memcached

  #
  # Testing
  #

  # Seperate test container so dev / test don't cause problems
  test:
    command: ["bash", "-c", "while true; do sleep 100; done;"]
    container_name: ensl_test
    build:
      context: ./
      dockerfile: Dockerfile
      target: ensl_development
    env_file:
      - .env.test
    ports:
      - ${TEST_APP_PORT}:${TEST_APP_PORT} # Capybara listens here
    links:
      - db
      - memcached
      - selenium
    volumes:
      - ".:/var/www"
    # command: bin/spring server
    environment:
      RAILS_ENV: test
    networks:
      default:
        aliases:
          - test

  selenium:
    image: selenium/standalone-chrome-debug
    container_name: ensl_selenium
    ports:
      - 5900:5900
      - 4444:4444

  #
  # Common services: These are shared by all envs.
  #

  memcached:
    image: memcached:alpine
    container_name: ensl_memcached

  redis:
    image: 'redis:4.0-alpine'
    container_name: ensl_redis

  db:
    image: mariadb:latest
    container_name: ensl_db
    user: "mysql:mysql"
    #    command: mysqld_safe --skip-grant-tables
    volumes:
     - "./db/data:/var/lib/mysql"
     - "./db/initdb.d:/docker-entrypoint-initdb.d"
     - "./ext/mysql.conf.d:/etc/mysql/conf.d"
    environment:
     - MYSQL_DATABASE=$MYSQL_DATABASE
     - MYSQL_USER=$MYSQL_USER
     - MYSQL_PASSWORD=$MYSQL_PASSWORD
     - MYSQL_ROOT_PASSWORD=$MYSQL_ROOT_PASSWORD
     - MYSQL_ROOT_HOST=$MYSQL_ROOT_HOST

  smtp:
    image: mwader/postfix-relay:latest
    container_name: ensl_smtp
    restart: always
    volumes:
     - "./ext/dkim:/etc/opendkim/keys"
    environment:
      - POSTFIX_myhostname=$MAIL_DOMAIN
      - OPENDKIM_DOMAINS=$MAIL_DOMAIN

  # This needs to be updated.
  # nginx:
  #   image: nginx:latest
  #   container_name: ensl_nginx
  #   tty: true
  #   stdin_open: true
  #   command: /bin/bash -c "cat /etc/nginx/conf.d/ensl_production/prod*.conf.template|envsubst '$$PRODUCTION_PUMA_PORT $$PRODUCTION_ROOT_DOMAIN $$PRODUCTION_DOMAIN $$PRODUCTION_PORT $$PRODUCTION_PORT_SSL $$PRODUCTION_NGINX_PUBLIC $$PUMA_PORT $$APP_PATH $$APP_PATH_PUBLIC $$STAGING_ROOT_DOMAIN $$STAGING_DOMAIN $$STAGING_PORT $$STAGING_PORT_SSL' > /etc/nginx/conf.d/default.conf && cat /etc/nginx/conf.d/*.conf && nginx -g 'daemon off;'"
  #   # TODO: use env vars here
  #   volumes:
  #     - ./ext/ssl:/etc/ssl
  #     - ./public/:/var/www
  #     - ./ext/nginx.conf.d:/etc/nginx/conf.d/ensl_production
  #     - ./ext/nginx.conf.d:/etc/nginx/conf.d/ensl_staging
  #     - ../ensl.org.staging/app/public:/var/staging/public
  #   # TODO: use env vars here
  #   ports:
  #     - 80:80
  #     - 443:443
  #     - 5000:5000
  #   environment:
  #     - PRODUCTION_PUMA_PORT=$PRODUCTION_PUMA_PORT
  #     - PRODUCTION_ROOT_DOMAIN=$PRODUCTION_ROOT_DOMAIN
  #     - PRODUCTION_DOMAIN=$PRODUCTION_DOMAIN
  #     - PRODUCTION_PORT=$PRODUCTION_PORT
  #     - PRODUCTION_PORT_SSL=$PRODUCTION_PORT_SSL
  #     - PRODUCTION_NGINX_PUBLIC=/srv/production
  #     - STAGING_PUMA_PORT=$STAGING_PUMA_PORT
  #     - STAGING_ROOT_DOMAIN=$STAGING_ROOT_DOMAIN
  #     - STAGING_DOMAIN=$STAGING_DOMAIN
  #     - STAGING_PORT=$STAGING_PORT
  #     - STAGING_PORT_SSL=$STAGING_PORT_SSL
  #     - STAGING_NGINX_PUBLIC=$STAGING_APP_PATH_PUBLIC

#  spring:
#    build:
#      context: ./
#      dockerfile: Dockerfile.dev
#      args:
#        buildno: 1
#    volumes:
#      - .:/var/www
#    command: spring server
# This ensures that the pid namespace is shared between the host
# and the container. It's not necessary to be able to run spring
# commands, but it is necessary for "spring status" and "spring stop"
# to work properly.
# pid: host
